{
  "CHANGELOG.html": {
    "href": "CHANGELOG.html",
    "title": "Changelog | Zentient.Metadata Documentation",
    "keywords": "Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog, and this project adheres to Semantic Versioning. [Unreleased] Added Initial project structure based on Zentient Library Template Example service implementation with Zentient.Abstractions integration Comprehensive test suite with xUnit Complete build automation through Directory.. files Changed Nothing yet Deprecated Nothing yet Removed Nothing yet Fixed Nothing yet Security Nothing yet [1.0.0] - 2025-08-09 Added Initial release of LIBRARY_NAME Core functionality for [describe your library's main purpose] Integration with Zentient.Abstractions framework Comprehensive documentation and examples Full test coverage Security analysis and vulnerability scanning Performance benchmarking infrastructure Automated NuGet package generation Features ExampleService: Template service showing Zentient patterns IResult Integration: Error handling using Zentient.Abstractions.Results IIdentifiable Support: Entity identification using Zentient.Abstractions.Common Comprehensive Testing: Unit tests, integration tests, and benchmarks Quality Assurance: Code analysis, StyleCop, and security scanning Documentation: XML docs, API documentation, and usage examples Technical Target Framework: .NET 8.0 Zentient.Abstractions: 3.0.1 Test Framework: xUnit 2.6.1 Code Coverage: Coverlet Benchmarking: BenchmarkDotNet Code Analysis: Microsoft.CodeAnalysis.NetAnalyzers, StyleCop.Analyzers Build System Directory.Build.props/targets: Core build configuration Directory.Pack.props/targets: NuGet packaging automation Directory.Sign.props/targets: Assembly signing with strong naming Directory.Test.props/targets: Comprehensive testing infrastructure Directory.Quality.props/targets: Code quality analysis and enforcement Directory.Security.props/targets: Security scanning and validation Directory.Documentation.props/targets: API documentation generation Directory.Performance.props/targets: Performance monitoring and benchmarking Development Experience VS Code Integration: Complete debugging, tasks, and extension configuration Zero Configuration: Works out of the box with no manual setup required Enterprise-Grade: Production-ready with comprehensive automation Extensible: Easy to customize and extend for specific needs Template for Future Releases [X.Y.Z] - YYYY-MM-DD Added New features added in this release Changed Changes in existing functionality Deprecated Soon-to-be removed features Removed Features removed in this release Fixed Bug fixes Security Security improvements and vulnerability fixes Guidelines for Maintaining This Changelog Categories Added for new features Changed for changes in existing functionality Deprecated for soon-to-be removed features Removed for now removed features Fixed for any bug fixes Security for vulnerability fixes Format Guidelines Date Format: Use ISO date format (YYYY-MM-DD) Version Numbers: Follow semantic versioning (MAJOR.MINOR.PATCH) Order: List releases in reverse chronological order (newest first) Links: Link to GitHub releases, issues, and pull requests when applicable Breaking Changes: Clearly mark breaking changes with ⚠️ symbol Examples Good Entries ### Added - User authentication system with JWT tokens (#123) - Database migration tool for version upgrades (#145) - REST API endpoints for user management (#167) ### Changed - ⚠️ BREAKING: Updated IUserService interface signature (#189) - Improved error messages for validation failures (#201) - Updated dependencies to latest versions (#215) ### Fixed - Fixed memory leak in background service (#178) - Resolved race condition in concurrent operations (#192) - Fixed incorrect error handling in API controllers (#204) ### Security - Updated vulnerable dependency packages (#210) - Implemented input sanitization for user data (#225) - Added rate limiting to prevent abuse (#240) Version Comparison Links At the bottom of the changelog, include comparison links: [Unreleased]: https://github.com/user/repo/compare/v1.0.0...HEAD [1.0.0]: https://github.com/user/repo/releases/tag/v1.0.0 Automation This changelog should be updated: Automatically: Through CI/CD pipeline for version bumps Manually: For each pull request that adds user-facing changes Before Release: Review and organize entries before creating a release Integration with Release Process Update changelog in feature branches Consolidate entries during release preparation Generate release notes from changelog entries Tag releases with version numbers matching changelog This ensures the changelog remains accurate and helpful for users understanding what changed between versions."
  },
  "CONTRIBUTING.html": {
    "href": "CONTRIBUTING.html",
    "title": "Contribution Guidelines | Zentient.Metadata Documentation",
    "keywords": "Contribution Guidelines Thank you for your interest in contributing to this Zentient library! This document provides guidelines and information for contributors. Getting Started Prerequisites .NET 8.0 SDK or later Git Visual Studio Code (recommended) or Visual Studio Basic understanding of C# and .NET Development Setup Fork and Clone git fork <repository-url> git clone <your-fork-url> cd <project-name> Install Dependencies dotnet restore Verify Setup dotnet build dotnet test Development Workflow Branching Strategy main - Stable release branch develop - Integration branch for features feature/<name> - Feature development bugfix/<name> - Bug fixes hotfix/<name> - Critical fixes for production Making Changes Create Feature Branch git checkout -b feature/your-feature-name Make Changes Follow the coding standards Add/update tests Update documentation Test Changes dotnet build dotnet test dotnet test --collect:\"XPlat Code Coverage\" Commit Changes git add . git commit -m \"feat: add your feature description\" Push and Create PR git push origin feature/your-feature-name Coding Standards Code Style This project follows the Zentient coding standards: Use PascalCase for public members Use camelCase for private fields and local variables Use UPPER_CASE for constants Prefix private fields with underscore: _fieldName Naming Conventions // Classes and Interfaces public class ExampleService { } public interface IExampleService { } // Methods and Properties public string ProcessData(string input) { } public string DataValue { get; set; } // Private fields private readonly string _connectionString; private static readonly ILogger _logger; // Constants public const int MAX_RETRY_COUNT = 3; private const string DEFAULT_CONFIG = \"default\"; Documentation All public APIs must have XML documentation: /// <summary> /// Processes the input data and returns a result. /// </summary> /// <param name=\"input\">The input data to process.</param> /// <returns>A result containing the processed data or an error.</returns> /// <exception cref=\"ArgumentNullException\">Thrown when input is null.</exception> public IResult<string> ProcessData(string input) { // Implementation } Code Organization // File: ExampleService.cs using System; using Zentient.Abstractions.Common; using Zentient.Abstractions.Results; namespace YourLibrary.Services; /// <summary> /// Service class documentation. /// </summary> public class ExampleService : IIdentifiable { // Constants first private const int DEFAULT_TIMEOUT = 30; // Static fields private static readonly ILogger _logger = LogManager.GetLogger<ExampleService>(); // Instance fields private readonly string _connectionString; // Properties public string Id { get; } = Guid.NewGuid().ToString(); // Constructors public ExampleService(string connectionString) { _connectionString = connectionString ?? throw new ArgumentNullException(nameof(connectionString)); } // Public methods public IResult<string> ProcessData(string input) { // Implementation } // Private methods private bool ValidateInput(string input) { // Implementation } } Testing Guidelines Test Structure namespace YourLibrary.Tests.Services; public class ExampleServiceTests { [Fact] public void ProcessData_WithValidInput_ReturnsSuccess() { // Arrange var service = new ExampleService(\"test-connection\"); var input = \"test data\"; // Act var result = service.ProcessData(input); // Assert Assert.True(result.IsSuccess); Assert.Equal(\"TEST DATA\", result.Value); } [Theory] [InlineData(null)] [InlineData(\"\")] [InlineData(\" \")] public void ProcessData_WithInvalidInput_ReturnsError(string input) { // Arrange var service = new ExampleService(\"test-connection\"); // Act var result = service.ProcessData(input); // Assert Assert.True(result.IsFailure); Assert.NotNull(result.Error); } } Test Coverage Aim for >90% code coverage Test both success and failure paths Include edge cases and boundary conditions Use descriptive test method names Group related tests in nested classes Performance Tests [Benchmark] public string ProcessData_Performance() { return _service.ProcessData(\"test input\").Value; } [Fact] public void ProcessData_PerformanceRequirement() { // Test should complete within acceptable time var stopwatch = Stopwatch.StartNew(); _service.ProcessData(\"test input\"); stopwatch.Stop(); Assert.True(stopwatch.ElapsedMilliseconds < 100); } Quality Requirements Code Analysis All code must pass: Microsoft .NET analyzers StyleCop analysis Security analysis Custom Zentient analyzers Security No hardcoded secrets or credentials Validate all inputs Use secure cryptographic algorithms Follow OWASP guidelines Performance No memory leaks Efficient algorithms Proper resource disposal Baseline performance maintained Pull Request Process Before Submitting Ensure Tests Pass dotnet test Check Code Quality dotnet build -p:RunCodeAnalysis=true dotnet build -p:RunSecurityCodeAnalysis=true Update Documentation Update XML documentation Update README if needed Update CHANGELOG.md Format Code dotnet format PR Requirements All tests pass Code coverage maintained/improved No analyzer warnings Documentation updated CHANGELOG.md updated Breaking changes documented PR Template ## Description Brief description of changes ## Type of Change - [ ] Bug fix - [ ] New feature - [ ] Breaking change - [ ] Documentation update ## Testing - [ ] Unit tests added/updated - [ ] Integration tests added/updated - [ ] Performance tests added/updated ## Checklist - [ ] Code follows style guidelines - [ ] Self-review completed - [ ] Documentation updated - [ ] Tests pass locally - [ ] CHANGELOG.md updated Review Process Automated checks run (CI/CD) Code review by maintainers Address feedback Final approval and merge Release Process Version Numbers We use Semantic Versioning: MAJOR.MINOR.PATCH Breaking changes increment MAJOR New features increment MINOR Bug fixes increment PATCH Release Workflow Create release branch from develop Update version numbers Update CHANGELOG.md Create release PR to main Tag release Publish NuGet package Community Communication Use GitHub Issues for bug reports Use GitHub Discussions for questions Follow our Code of Conduct Be respectful and constructive Getting Help Check existing documentation Search existing issues Ask in GitHub Discussions Contact maintainers if needed Resources Zentient.Abstractions Documentation .NET Coding Conventions xUnit Documentation BenchmarkDotNet Documentation Thank you for contributing to the Zentient ecosystem! 🚀"
  },
  "README.html": {
    "href": "README.html",
    "title": "Zentient.Metadata | Zentient.Metadata Documentation",
    "keywords": "Zentient.Metadata <<<<<<< HEAD A modern, extensible metadata platform for .NET. This monorepo contains the core packages used to declare, compose, discover, and analyze metadata in libraries and applications. origin/main What’s inside Zentient.Metadata — Core metadata engine (immutable metadata, fluent builder, scanners) Zentient.Metadata.Attributes — Attribute-based metadata discovery and conversion Zentient.Metadata.Abstractions — Interfaces and contracts used across packages Zentient.Metadata.Analyzers — Roslyn analyzers for best practices and correctness Zentient.Metadata.Diagnostics — Diagnostic helpers and profiles Goals Provide a small, stable set of abstractions for metadata composition and discovery Offer a flexible runtime model with first-class support for attribute-driven metadata Deliver tooling (analyzers and diagnostics) to improve developer experience Quick start Add the package you need: dotnet add package Zentient.Metadata # or dotnet add package Zentient.Metadata.Attributes Build metadata using the fluent API: var metadata = Metadata.Create() .SetTag(\"Version\", \"1.0.0\") .SetTag(\"Author\", \"Zentient Team\") .Build(); var version = metadata.GetValueOrDefault<string>(\"Version\"); Documentation API reference: https://ulfbou.github.io/Zentient.Metadata/ Specification and design docs: docs/ CHANGELOG: CHANGELOG.md CI / Release The repository uses GitHub Actions (.github/workflows/ci-cd.yml) to run restore, build, test, pack, and publish. Releases are triggered by tags using the form vMAJOR.MINOR.PATCH and publish packages to NuGet.org. Contributing See CONTRIBUTING.md for contribution and release guidelines. Open issues and PRs on GitHub; all changes should include tests and updates to CHANGELOG.md when applicable. License MIT — see LICENSE file."
  },
  "api/Zentient.Abstractions.Metadata.Diagnostics.IDiagnosticCheckDefinition.html": {
    "href": "api/Zentient.Abstractions.Metadata.Diagnostics.IDiagnosticCheckDefinition.html",
    "title": "Interface IDiagnosticCheckDefinition | Zentient.Metadata Documentation",
    "keywords": "Interface IDiagnosticCheckDefinition Represents a definition for a diagnostic check that can be discovered, profiled, and executed. Inherited Members IIdentifiable.Id IHasName.Name IHasVersion.Version IHasDescription.Description IHasCategory.CategoryName IHasCategory.Category IHasRelation.Relations IHasMetadata.Metadata Namespace: Zentient.Abstractions.Metadata.Diagnostics Assembly: Zentient.Metadata.Abstractions.dll Syntax public interface IDiagnosticCheckDefinition : ITypeDefinition, IIdentifiableDefinition, IDefinition, IIdentifiable, IHasName, IHasVersion, IHasDescription, IHasCategory, IHasRelation, IHasMetadata Properties View Source DiagnosticsCategory Declaration string DiagnosticsCategory { get; } Property Value Type Description string View Source DisplayName Declaration string DisplayName { get; } Property Value Type Description string View Source TargetComponentType Declaration Type TargetComponentType { get; } Property Value Type Description Type"
  },
  "api/Zentient.Abstractions.Metadata.Diagnostics.html": {
    "href": "api/Zentient.Abstractions.Metadata.Diagnostics.html",
    "title": "Namespace Zentient.Abstractions.Metadata.Diagnostics | Zentient.Metadata Documentation",
    "keywords": "Namespace Zentient.Abstractions.Metadata.Diagnostics Interfaces IDiagnosticCheckDefinition Represents a definition for a diagnostic check that can be discovered, profiled, and executed."
  },
  "api/Zentient.Abstractions.Metadata.IMetadataDefinition.html": {
    "href": "api/Zentient.Abstractions.Metadata.IMetadataDefinition.html",
    "title": "Interface IMetadataDefinition | Zentient.Metadata Documentation",
    "keywords": "Interface IMetadataDefinition Definition-level metadata (type-centric). Supports behavior and category declarations. Namespace: Zentient.Abstractions.Metadata Assembly: Zentient.Metadata.Abstractions.dll Syntax public interface IMetadataDefinition : IMetadataDefinition, IDefinition"
  },
  "api/Zentient.Abstractions.Metadata.IMetadataScanner.html": {
    "href": "api/Zentient.Abstractions.Metadata.IMetadataScanner.html",
    "title": "Interface IMetadataScanner | Zentient.Metadata Documentation",
    "keywords": "Interface IMetadataScanner Scans assemblies, types, or members to generate IMetadata. Must be deterministic and extensible. Namespace: Zentient.Abstractions.Metadata Assembly: Zentient.Metadata.Abstractions.dll Syntax public interface IMetadataScanner Methods View Source Scan(MemberInfo) Declaration IMetadata Scan(MemberInfo member) Parameters Type Name Description MemberInfo member Returns Type Description IMetadata View Source Scan(Type) Declaration IMetadata Scan(Type type) Parameters Type Name Description Type type Returns Type Description IMetadata View Source ScanAll(Assembly) Declaration IEnumerable<(MemberInfo member, IMetadata metadata)> ScanAll(Assembly assembly) Parameters Type Name Description Assembly assembly Returns Type Description IEnumerable<(MemberInfo member, IMetadata metadata)>"
  },
  "api/Zentient.Abstractions.Metadata.IMetadataTag.html": {
    "href": "api/Zentient.Abstractions.Metadata.IMetadataTag.html",
    "title": "Interface IMetadataTag | Zentient.Metadata Documentation",
    "keywords": "Interface IMetadataTag Represents a key-value pair in metadata. Keys can be type-based or preset-based. Namespace: Zentient.Abstractions.Metadata Assembly: Zentient.Metadata.Abstractions.dll Syntax public interface IMetadataTag Properties View Source Key Declaration object Key { get; } Property Value Type Description object View Source Value Declaration object? Value { get; } Property Value Type Description object"
  },
  "api/Zentient.Abstractions.Metadata.IPresetKey.html": {
    "href": "api/Zentient.Abstractions.Metadata.IPresetKey.html",
    "title": "Interface IPresetKey | Zentient.Metadata Documentation",
    "keywords": "Interface IPresetKey Represents a typed or registered preset identifier. Namespace: Zentient.Abstractions.Metadata Assembly: Zentient.Metadata.Abstractions.dll Syntax public interface IPresetKey Properties View Source Name Declaration string Name { get; } Property Value Type Description string"
  },
  "api/Zentient.Abstractions.Metadata.html": {
    "href": "api/Zentient.Abstractions.Metadata.html",
    "title": "Namespace Zentient.Abstractions.Metadata | Zentient.Metadata Documentation",
    "keywords": "Namespace Zentient.Abstractions.Metadata Interfaces IMetadataDefinition Definition-level metadata (type-centric). Supports behavior and category declarations. IMetadataScanner Scans assemblies, types, or members to generate IMetadata. Must be deterministic and extensible. IMetadataTag Represents a key-value pair in metadata. Keys can be type-based or preset-based. IPresetKey Represents a typed or registered preset identifier."
  },
  "api/Zentient.Metadata.Analyzers.DuplicateMetadataTagAnalyzer.html": {
    "href": "api/Zentient.Metadata.Analyzers.DuplicateMetadataTagAnalyzer.html",
    "title": "Class DuplicateMetadataTagAnalyzer | Zentient.Metadata Documentation",
    "keywords": "Class DuplicateMetadataTagAnalyzer Inheritance object DuplicateMetadataTagAnalyzer Namespace: Zentient.Metadata.Analyzers Assembly: Zentient.Metadata.Analyzers.dll Syntax public class DuplicateMetadataTagAnalyzer : DiagnosticAnalyzer Constructors View Source DuplicateMetadataTagAnalyzer() Declaration public DuplicateMetadataTagAnalyzer() Fields View Source DiagnosticId Declaration public const string DiagnosticId = \"ZMD002\" Field Value Type Description string Properties View Source SupportedDiagnostics Declaration public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; } Property Value Type Description ImmutableArray<DiagnosticDescriptor> Methods View Source Initialize(AnalysisContext) Declaration public override void Initialize(AnalysisContext context) Parameters Type Name Description AnalysisContext context"
  },
  "api/Zentient.Metadata.Analyzers.InvalidAttributeTargetAnalyzer.html": {
    "href": "api/Zentient.Metadata.Analyzers.InvalidAttributeTargetAnalyzer.html",
    "title": "Class InvalidAttributeTargetAnalyzer | Zentient.Metadata Documentation",
    "keywords": "Class InvalidAttributeTargetAnalyzer Analyzer that detects invalid usage of Zentient.Metadata attributes on unsupported targets. Inheritance object InvalidAttributeTargetAnalyzer Namespace: Zentient.Metadata.Analyzers Assembly: Zentient.Metadata.Analyzers.dll Syntax public class InvalidAttributeTargetAnalyzer : DiagnosticAnalyzer Constructors View Source InvalidAttributeTargetAnalyzer() Declaration public InvalidAttributeTargetAnalyzer() Fields View Source DiagnosticId Declaration public const string DiagnosticId = \"ZMD001\" Field Value Type Description string Properties View Source SupportedDiagnostics Declaration public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; } Property Value Type Description ImmutableArray<DiagnosticDescriptor> Methods View Source Initialize(AnalysisContext) Declaration public override void Initialize(AnalysisContext context) Parameters Type Name Description AnalysisContext context"
  },
  "api/Zentient.Metadata.Analyzers.MissingDocumentationAnalyzer.html": {
    "href": "api/Zentient.Metadata.Analyzers.MissingDocumentationAnalyzer.html",
    "title": "Class MissingDocumentationAnalyzer | Zentient.Metadata Documentation",
    "keywords": "Class MissingDocumentationAnalyzer Inheritance object MissingDocumentationAnalyzer Namespace: Zentient.Metadata.Analyzers Assembly: Zentient.Metadata.Analyzers.dll Syntax public class MissingDocumentationAnalyzer : DiagnosticAnalyzer Constructors View Source MissingDocumentationAnalyzer() Declaration public MissingDocumentationAnalyzer() Fields View Source DiagnosticId The diagnostic ID for missing documentation. Declaration public const string DiagnosticId = \"ZMD004\" Field Value Type Description string Properties View Source SupportedDiagnostics Declaration public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; } Property Value Type Description ImmutableArray<DiagnosticDescriptor> Methods View Source Initialize(AnalysisContext) Declaration public override void Initialize(AnalysisContext context) Parameters Type Name Description AnalysisContext context"
  },
  "api/Zentient.Metadata.Analyzers.MissingInterfaceAnalyzer.html": {
    "href": "api/Zentient.Metadata.Analyzers.MissingInterfaceAnalyzer.html",
    "title": "Class MissingInterfaceAnalyzer | Zentient.Metadata Documentation",
    "keywords": "Class MissingInterfaceAnalyzer Inheritance object MissingInterfaceAnalyzer Namespace: Zentient.Metadata.Analyzers Assembly: Zentient.Metadata.Analyzers.dll Syntax public class MissingInterfaceAnalyzer : DiagnosticAnalyzer Constructors View Source MissingInterfaceAnalyzer() Declaration public MissingInterfaceAnalyzer() Fields View Source DiagnosticId Declaration public const string DiagnosticId = \"ZMD003\" Field Value Type Description string Properties View Source SupportedDiagnostics Declaration public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; } Property Value Type Description ImmutableArray<DiagnosticDescriptor> Methods View Source Initialize(AnalysisContext) Declaration public override void Initialize(AnalysisContext context) Parameters Type Name Description AnalysisContext context"
  },
  "api/Zentient.Metadata.Analyzers.html": {
    "href": "api/Zentient.Metadata.Analyzers.html",
    "title": "Namespace Zentient.Metadata.Analyzers | Zentient.Metadata Documentation",
    "keywords": "Namespace Zentient.Metadata.Analyzers Classes DuplicateMetadataTagAnalyzer InvalidAttributeTargetAnalyzer Analyzer that detects invalid usage of Zentient.Metadata attributes on unsupported targets. MissingDocumentationAnalyzer MissingInterfaceAnalyzer"
  },
  "api/Zentient.Metadata.Attributes.AttributeHandlerContext.html": {
    "href": "api/Zentient.Metadata.Attributes.AttributeHandlerContext.html",
    "title": "Class AttributeHandlerContext | Zentient.Metadata Documentation",
    "keywords": "Class AttributeHandlerContext Context passed to attribute handler delegates. Inheritance object AttributeHandlerContext Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Zentient.Metadata.Attributes Assembly: Zentient.Metadata.Attributes.dll Syntax public sealed class AttributeHandlerContext Constructors View Source AttributeHandlerContext(IMetadataBuilder) Declaration public AttributeHandlerContext(IMetadataBuilder builder) Parameters Type Name Description IMetadataBuilder builder Properties View Source Builder Declaration public IMetadataBuilder Builder { get; } Property Value Type Description IMetadataBuilder"
  },
  "api/Zentient.Metadata.Attributes.AttributeHandlerRegistry.html": {
    "href": "api/Zentient.Metadata.Attributes.AttributeHandlerRegistry.html",
    "title": "Class AttributeHandlerRegistry | Zentient.Metadata Documentation",
    "keywords": "Class AttributeHandlerRegistry Registry for custom attribute handlers for metadata conversion. Inheritance object AttributeHandlerRegistry Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Zentient.Metadata.Attributes Assembly: Zentient.Metadata.Attributes.dll Syntax public static class AttributeHandlerRegistry Methods View Source Register<TAttr>(Action<TAttr, AttributeHandlerContext>) Registers a handler for a custom attribute type. Declaration public static void Register<TAttr>(Action<TAttr, AttributeHandlerContext> handler) where TAttr : Attribute Parameters Type Name Description Action<TAttr, AttributeHandlerContext> handler The handler delegate. Type Parameters Name Description TAttr The attribute type. View Source TryHandle(Attribute, AttributeHandlerContext) Invokes a registered handler for the given attribute, if present. Declaration public static bool TryHandle(Attribute attr, AttributeHandlerContext ctx) Parameters Type Name Description Attribute attr AttributeHandlerContext ctx Returns Type Description bool"
  },
  "api/Zentient.Metadata.Attributes.AttributeMetadataConverter.html": {
    "href": "api/Zentient.Metadata.Attributes.AttributeMetadataConverter.html",
    "title": "Class AttributeMetadataConverter | Zentient.Metadata Documentation",
    "keywords": "Class AttributeMetadataConverter Provides conversion from attribute collections to IMetadata. Inheritance object AttributeMetadataConverter Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Zentient.Metadata.Attributes Assembly: Zentient.Metadata.Attributes.dll Syntax public static class AttributeMetadataConverter Methods View Source Convert(IEnumerable<Attribute>) Converts a collection of attributes into an Zentient.Abstractions.Metadata.IMetadata instance. Declaration public static IMetadata Convert(IEnumerable<Attribute> attributes) Parameters Type Name Description IEnumerable<Attribute> attributes The collection of attributes to convert. Returns Type Description IMetadata An Zentient.Abstractions.Metadata.IMetadata instance representing the metadata defined by the attributes. Exceptions Type Condition ArgumentNullException Thrown if attributes is null."
  },
  "api/Zentient.Metadata.Attributes.AttributeMetadataScanner.html": {
    "href": "api/Zentient.Metadata.Attributes.AttributeMetadataScanner.html",
    "title": "Class AttributeMetadataScanner | Zentient.Metadata Documentation",
    "keywords": "Class AttributeMetadataScanner Provides an implementation of IAttributeMetadataScanner that uses MetadataAttributeReader to scan types and members for metadata attributes and produce Zentient.Abstractions.Metadata.IMetadata instances. Inheritance object AttributeMetadataScanner Implements IAttributeMetadataScanner Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Zentient.Metadata.Attributes Assembly: Zentient.Metadata.Attributes.dll Syntax public class AttributeMetadataScanner : IAttributeMetadataScanner Constructors View Source AttributeMetadataScanner() Declaration public AttributeMetadataScanner() Methods View Source Scan(MemberInfo) Scans a MemberInfo for metadata attributes and produces an Zentient.Abstractions.Metadata.IMetadata instance. Declaration public IMetadata Scan(MemberInfo member) Parameters Type Name Description MemberInfo member The member to scan for metadata attributes. Returns Type Description IMetadata An Zentient.Abstractions.Metadata.IMetadata instance representing the metadata found on the member. View Source Scan(Type) Scans a Type for metadata attributes and produces an Zentient.Abstractions.Metadata.IMetadata instance. Declaration public IMetadata Scan(Type type) Parameters Type Name Description Type type The type to scan for metadata attributes. Returns Type Description IMetadata An Zentient.Abstractions.Metadata.IMetadata instance representing the metadata found on the type. View Source ScanAll(Assembly) Scans all types and members in an Assembly for metadata attributes. Declaration public IEnumerable<(MemberInfo member, IMetadata metadata)> ScanAll(Assembly assembly) Parameters Type Name Description Assembly assembly The assembly to scan. Returns Type Description IEnumerable<(MemberInfo member, IMetadata metadata)> An enumerable of tuples, each containing a MemberInfo and its associated Zentient.Abstractions.Metadata.IMetadata. Implements IAttributeMetadataScanner"
  },
  "api/Zentient.Metadata.Attributes.BehaviorDefinitionAttribute.html": {
    "href": "api/Zentient.Metadata.Attributes.BehaviorDefinitionAttribute.html",
    "title": "Class BehaviorDefinitionAttribute | Zentient.Metadata Documentation",
    "keywords": "Class BehaviorDefinitionAttribute Declares a type as a metadata behavior definition. Use on classes or interfaces implementing Zentient.Abstractions.Metadata.Definitions.IBehaviorDefinition. Inheritance object Attribute MetadataAttribute BehaviorDefinitionAttribute Inherited Members MetadataAttribute.Order MetadataAttribute.Preset Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Zentient.Metadata.Attributes Assembly: Zentient.Metadata.Attributes.dll Syntax [AttributeUsage(AttributeTargets.Class|AttributeTargets.Interface, Inherited = false, AllowMultiple = false)] public sealed class BehaviorDefinitionAttribute : MetadataAttribute Remarks This attribute is a marker for behavior definitions in the Zentient ecosystem. Examples [BehaviorDefinition] public class AuditableBehavior : IBehaviorDefinition Constructors View Source BehaviorDefinitionAttribute(int, string?) Initializes a new instance of the BehaviorDefinitionAttribute class. Declaration public BehaviorDefinitionAttribute(int order = 0, string? preset = null) Parameters Type Name Description int order The order in which this attribute should be processed. string preset An optional preset name associated with the attribute."
  },
  "api/Zentient.Metadata.Attributes.CategoryDefinitionAttribute.html": {
    "href": "api/Zentient.Metadata.Attributes.CategoryDefinitionAttribute.html",
    "title": "Class CategoryDefinitionAttribute | Zentient.Metadata Documentation",
    "keywords": "Class CategoryDefinitionAttribute Declares a type as a metadata category definition. Use on classes or interfaces implementing Zentient.Abstractions.Metadata.Definitions.ICategoryDefinition. Inheritance object Attribute MetadataAttribute CategoryDefinitionAttribute Inherited Members MetadataAttribute.Order MetadataAttribute.Preset Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Zentient.Metadata.Attributes Assembly: Zentient.Metadata.Attributes.dll Syntax [AttributeUsage(AttributeTargets.Class|AttributeTargets.Interface, Inherited = false, AllowMultiple = false)] public sealed class CategoryDefinitionAttribute : MetadataAttribute Remarks This attribute is a marker for category definitions in the Zentient ecosystem. Examples [CategoryDefinition(\"service\")] public class ServiceCategory : ICategoryDefinition Constructors View Source CategoryDefinitionAttribute(string?, int, string?) Initializes a new instance of the CategoryDefinitionAttribute class. Declaration public CategoryDefinitionAttribute(string? name = null, int order = 0, string? preset = null) Parameters Type Name Description string name The human-readable name of the category. int order The order in which this attribute should be processed. string preset An optional preset name associated with the attribute. Properties View Source Name Gets the optional, human-readable name of the category. Declaration public string Name { get; } Property Value Type Description string"
  },
  "api/Zentient.Metadata.Attributes.IAttributeMetadataScanner.html": {
    "href": "api/Zentient.Metadata.Attributes.IAttributeMetadataScanner.html",
    "title": "Interface IAttributeMetadataScanner | Zentient.Metadata Documentation",
    "keywords": "Interface IAttributeMetadataScanner Defines a contract for scanning types and members for metadata attributes and producing Zentient.Abstractions.Metadata.IMetadata instances. Namespace: Zentient.Metadata.Attributes Assembly: Zentient.Metadata.Attributes.dll Syntax public interface IAttributeMetadataScanner Methods View Source Scan(MemberInfo) Scans a MemberInfo for metadata attributes and produces an Zentient.Abstractions.Metadata.IMetadata instance. Declaration IMetadata Scan(MemberInfo member) Parameters Type Name Description MemberInfo member The member to scan for metadata attributes. Returns Type Description IMetadata An Zentient.Abstractions.Metadata.IMetadata instance representing the metadata found on the member. View Source Scan(Type) Scans a Type for metadata attributes and produces an Zentient.Abstractions.Metadata.IMetadata instance. Declaration IMetadata Scan(Type type) Parameters Type Name Description Type type The type to scan for metadata attributes. Returns Type Description IMetadata An Zentient.Abstractions.Metadata.IMetadata instance representing the metadata found on the type. View Source ScanAll(Assembly) Scans all types and members in an Assembly for metadata attributes. Declaration IEnumerable<(MemberInfo member, IMetadata metadata)> ScanAll(Assembly assembly) Parameters Type Name Description Assembly assembly The assembly to scan. Returns Type Description IEnumerable<(MemberInfo member, IMetadata metadata)> An enumerable of tuples, each containing a MemberInfo and its associated Zentient.Abstractions.Metadata.IMetadata."
  },
  "api/Zentient.Metadata.Attributes.MetadataAttribute.html": {
    "href": "api/Zentient.Metadata.Attributes.MetadataAttribute.html",
    "title": "Class MetadataAttribute | Zentient.Metadata Documentation",
    "keywords": "Class MetadataAttribute Serves as the base class for all metadata-related attributes within the Zentient Framework. This abstract class provides a common base for discovery and future extensibility. Inheritance object Attribute MetadataAttribute BehaviorDefinitionAttribute CategoryDefinitionAttribute MetadataTagAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Zentient.Metadata.Attributes Assembly: Zentient.Metadata.Attributes.dll Syntax [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] public abstract class MetadataAttribute : Attribute Remarks All custom metadata attributes should inherit from this class to be consistently discoverable by the Zentient metadata engine and analyzers. Examples // Custom attribute example public sealed class MyCustomTagAttribute : MetadataAttribute Constructors View Source MetadataAttribute(int, string?) Initializes a new instance of the MetadataAttribute class. Declaration public MetadataAttribute(int order = 0, string? preset = null) Parameters Type Name Description int order The order in which this attribute should be processed. Higher numbers have higher priority in conflict resolution. string preset An optional preset name associated with the attribute. Properties View Source Order Gets or sets the order in which this attribute should be processed. Higher numbers have higher priority in conflict resolution. Declaration public int Order { get; set; } Property Value Type Description int View Source Preset Gets or sets an optional preset name associated with the attribute. Declaration public string Preset { get; set; } Property Value Type Description string"
  },
  "api/Zentient.Metadata.Attributes.MetadataAttributeReader.html": {
    "href": "api/Zentient.Metadata.Attributes.MetadataAttributeReader.html",
    "title": "Class MetadataAttributeReader | Zentient.Metadata Documentation",
    "keywords": "Class MetadataAttributeReader Provides utilities for discovering and reading metadata attributes from types and constructing Zentient.Abstractions.Metadata.IMetadata instances. Inheritance object MetadataAttributeReader Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Zentient.Metadata.Attributes Assembly: Zentient.Metadata.Attributes.dll Syntax public static class MetadataAttributeReader Remarks This class supports unified discovery of Zentient.Metadata and Zentient.Abstractions.Common.Metadata attributes. Examples var metadata = MetadataAttributeReader.GetMetadata(typeof(MyService)); // metadata will have tags \"VersionTag\"=\"1.2\", \"CacheableTag\"=true Methods View Source GetMetadata(MemberInfo) Scans a given member (property, method, event, etc.) for metadata attributes, returning an Zentient.Abstractions.Metadata.IMetadata instance. Declaration public static IMetadata GetMetadata(MemberInfo member) Parameters Type Name Description MemberInfo member The member to scan for metadata attributes. Returns Type Description IMetadata An Zentient.Abstractions.Metadata.IMetadata instance containing all discovered metadata, or an empty instance if none are found. Exceptions Type Condition ArgumentNullException Thrown if the member is null. View Source GetMetadata(Type) Scans a given type and its base types for metadata attributes, returning a consolidated Zentient.Abstractions.Metadata.IMetadata instance. Declaration public static IMetadata GetMetadata(Type type) Parameters Type Name Description Type type The type to scan for metadata attributes. Returns Type Description IMetadata An Zentient.Abstractions.Metadata.IMetadata instance containing all discovered metadata, or an empty instance if none are found. Exceptions Type Condition ArgumentNullException Thrown if the type is null."
  },
  "api/Zentient.Metadata.Attributes.MetadataTagAttribute.html": {
    "href": "api/Zentient.Metadata.Attributes.MetadataTagAttribute.html",
    "title": "Class MetadataTagAttribute | Zentient.Metadata Documentation",
    "keywords": "Class MetadataTagAttribute Associates a metadata tag on a type or member. Use for key-value metadata tagging. Inheritance object Attribute MetadataAttribute MetadataTagAttribute Inherited Members MetadataAttribute.Order MetadataAttribute.Preset Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: Zentient.Metadata.Attributes Assembly: Zentient.Metadata.Attributes.dll Syntax [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method|AttributeTargets.Property, Inherited = false, AllowMultiple = true)] public sealed class MetadataTagAttribute : MetadataAttribute Remarks This attribute is repeatable and can be used for multiple tags on the same type/member. Examples [MetadataTag(typeof(VersionTag), \"1.2\")] [MetadataTag(typeof(CacheableTag), true)] public class MyService Constructors View Source MetadataTagAttribute(Type, object?, int, string?) Initializes a new instance of the MetadataTagAttribute class. Declaration public MetadataTagAttribute(Type tagType, object? value, int order = 0, string? preset = null) Parameters Type Name Description Type tagType The tag type used as the key. object value The value associated with the tag. int order The order in which this attribute should be processed. string preset An optional preset name associated with the attribute. Properties View Source Key Gets the key for the tag (the full name of the tag type). Declaration public string Key { get; } Property Value Type Description string View Source TagType Gets the tag type used as the key. Declaration public Type TagType { get; } Property Value Type Description Type View Source TagValue Gets the value associated with the tag. Declaration public object? TagValue { get; } Property Value Type Description object"
  },
  "api/Zentient.Metadata.Attributes.html": {
    "href": "api/Zentient.Metadata.Attributes.html",
    "title": "Namespace Zentient.Metadata.Attributes | Zentient.Metadata Documentation",
    "keywords": "Namespace Zentient.Metadata.Attributes Classes AttributeHandlerContext Context passed to attribute handler delegates. AttributeHandlerRegistry Registry for custom attribute handlers for metadata conversion. AttributeMetadataConverter Provides conversion from attribute collections to IMetadata. AttributeMetadataScanner Provides an implementation of IAttributeMetadataScanner that uses MetadataAttributeReader to scan types and members for metadata attributes and produce Zentient.Abstractions.Metadata.IMetadata instances. BehaviorDefinitionAttribute Declares a type as a metadata behavior definition. Use on classes or interfaces implementing Zentient.Abstractions.Metadata.Definitions.IBehaviorDefinition. CategoryDefinitionAttribute Declares a type as a metadata category definition. Use on classes or interfaces implementing Zentient.Abstractions.Metadata.Definitions.ICategoryDefinition. MetadataAttribute Serves as the base class for all metadata-related attributes within the Zentient Framework. This abstract class provides a common base for discovery and future extensibility. MetadataAttributeReader Provides utilities for discovering and reading metadata attributes from types and constructing Zentient.Abstractions.Metadata.IMetadata instances. MetadataTagAttribute Associates a metadata tag on a type or member. Use for key-value metadata tagging. Interfaces IAttributeMetadataScanner Defines a contract for scanning types and members for metadata attributes and producing Zentient.Abstractions.Metadata.IMetadata instances."
  },
  "api/Zentient.Metadata.Metadata.html": {
    "href": "api/Zentient.Metadata.Metadata.html",
    "title": "Class Metadata | Zentient.Metadata Documentation",
    "keywords": "Class Metadata Serves as the public-facing factory for creating new Zentient.Abstractions.Metadata.IMetadata instances. This is the primary entry point for consumers to interact with the metadata system. Inheritance object Metadata Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Zentient.Metadata Assembly: Zentient.Metadata.dll Syntax public static class Metadata Properties View Source Empty Gets an empty, immutable Zentient.Abstractions.Metadata.IMetadata instance. Declaration public static IMetadata Empty { get; } Property Value Type Description IMetadata Methods View Source Create() Creates a new, fluent builder for an Zentient.Abstractions.Metadata.IMetadata instance. Declaration public static IMetadataBuilder Create() Returns Type Description IMetadataBuilder A new Zentient.Abstractions.Metadata.Builders.IMetadataBuilder instance. View Source WithBehavior<TBehavior>() Creates a new Zentient.Abstractions.Metadata.IMetadata instance with a single behavior. Declaration public static IMetadata WithBehavior<TBehavior>() where TBehavior : IBehaviorDefinition, new() Returns Type Description IMetadata A new Zentient.Abstractions.Metadata.IMetadata instance containing the specified behavior. Type Parameters Name Description TBehavior The concrete behavior definition type, which must implement Zentient.Abstractions.Metadata.Definitions.IBehaviorDefinition. View Source WithCategory<TCategory>() Creates a new Zentient.Abstractions.Metadata.IMetadata instance with a single category. Declaration public static IMetadata WithCategory<TCategory>() where TCategory : ICategoryDefinition, new() Returns Type Description IMetadata A new Zentient.Abstractions.Metadata.IMetadata instance containing the specified category. Type Parameters Name Description TCategory The concrete category definition type, which must implement Zentient.Abstractions.Metadata.Definitions.ICategoryDefinition. View Source WithTag<TTag, TValue>(TValue) Creates a new Zentient.Abstractions.Metadata.IMetadata instance with a single tag. Declaration public static IMetadata WithTag<TTag, TValue>(TValue value) where TTag : IMetadataTagDefinition, new() Parameters Type Name Description TValue value The value of the tag. Returns Type Description IMetadata A new Zentient.Abstractions.Metadata.IMetadata instance containing the specified tag. Type Parameters Name Description TTag The concrete tag definition type, which must implement Zentient.Abstractions.Metadata.Definitions.IMetadataTagDefinition. TValue The type of the tag's value."
  },
  "api/Zentient.Metadata.MetadataExtensions.html": {
    "href": "api/Zentient.Metadata.MetadataExtensions.html",
    "title": "Class MetadataExtensions | Zentient.Metadata Documentation",
    "keywords": "Class MetadataExtensions Provides a rich set of fluent, type-safe extension methods for working with Zentient.Abstractions.Metadata.IMetadata. These methods enhance developer ergonomics and enable intuitive interactions with the metadata system. Inheritance object MetadataExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Zentient.Metadata Assembly: Zentient.Metadata.dll Syntax public static class MetadataExtensions Methods View Source GetBehavior<TBehavior>(IMetadata) Attempts to retrieve a behavior from the metadata. Declaration public static IMetadata? GetBehavior<TBehavior>(this IMetadata metadata) where TBehavior : IBehaviorDefinition Parameters Type Name Description IMetadata metadata The metadata instance to query. Returns Type Description IMetadata The metadata instance representing the behavior, or null if not found. Type Parameters Name Description TBehavior The concrete behavior definition type. View Source GetTagValue<TValue>(IMetadata, string, TValue) Declaration public static TValue GetTagValue<TValue>(this IMetadata metadata, string key, TValue defaultValue = default) Parameters Type Name Description IMetadata metadata string key TValue defaultValue Returns Type Description TValue Type Parameters Name Description TValue View Source GetTagValue<TTag, TValue>(IMetadata, TValue) Gets the value of a tag in a type-safe manner. Declaration public static TValue GetTagValue<TTag, TValue>(this IMetadata metadata, TValue defaultValue = default) where TTag : IMetadataTagDefinition, new() Parameters Type Name Description IMetadata metadata The metadata instance to query. TValue defaultValue The value to return if the tag does not exist or has the wrong type. Returns Type Description TValue The value of the tag, or the default value if not found or the type is incorrect. Type Parameters Name Description TTag The concrete tag definition type. TValue The expected type of the tag's value. View Source GetValueOrDefault<TValue>(IMetadata, string, TValue) Gets the value of a tag or retrieves a default value if the tag is not present or cannot be cast to the desired type. Declaration public static TValue GetValueOrDefault<TValue>(this IMetadata metadata, string key, TValue defaultValue = default) Parameters Type Name Description IMetadata metadata The metadata instance to query. string key The key of the tag to retrieve. TValue defaultValue The default value to return if the tag is not present or cannot be cast. Returns Type Description TValue The value of the tag, or the default value if the tag is not present or cannot be cast. Type Parameters Name Description TValue The expected type of the tag's value. View Source HasBehavior<TBehavior>(IMetadata) Checks if the metadata contains a specific behavior. Declaration public static bool HasBehavior<TBehavior>(this IMetadata metadata) where TBehavior : IBehaviorDefinition Parameters Type Name Description IMetadata metadata The metadata instance to query. Returns Type Description bool True if the behavior is present; otherwise, false. Type Parameters Name Description TBehavior The concrete behavior definition type. View Source HasCategory<TCategory>(IMetadata) Checks if the metadata is associated with a specific category. Declaration public static bool HasCategory<TCategory>(this IMetadata metadata) where TCategory : ICategoryDefinition Parameters Type Name Description IMetadata metadata The metadata instance to query. Returns Type Description bool True if the category is present; otherwise, false. Type Parameters Name Description TCategory The concrete category definition type. View Source HasTag<TTag>(IMetadata) Checks if the metadata contains a specific tag. Declaration public static bool HasTag<TTag>(this IMetadata metadata) where TTag : IMetadataTagDefinition Parameters Type Name Description IMetadata metadata The metadata instance to query. Returns Type Description bool True if the tag is present; otherwise, false. Type Parameters Name Description TTag The concrete tag definition type. View Source TryGetTagValue<TTag, TValue>(IMetadata, out TValue) Tries to get the value of a tag in a type-safe manner. Declaration public static bool TryGetTagValue<TTag, TValue>(this IMetadata metadata, out TValue value) where TTag : IMetadataTagDefinition, new() Parameters Type Name Description IMetadata metadata The metadata instance to query. TValue value When this method returns, contains the value of the tag, if found and if the type is correct; otherwise, the default value for the type. Returns Type Description bool True if the value was successfully retrieved; otherwise, false. Type Parameters Name Description TTag The concrete tag definition type. TValue The expected type of the tag's value. View Source TryGetValue<TValue>(IMetadata, string, out TValue?) Tries to retrieve a value from the metadata based on the specified key and casts it to the desired type. Declaration public static bool TryGetValue<TValue>(this IMetadata metadata, string key, out TValue? value) Parameters Type Name Description IMetadata metadata The metadata instance to query. string key The key of the value to retrieve. TValue value When this method returns, contains the casted value if the operation was successful; otherwise, the default value for the type. Returns Type Description bool True if the value was successfully retrieved and casted; otherwise, false. Type Parameters Name Description TValue The expected type of the value. View Source WithBehavior<TBehavior>(IMetadata) Adds a behavior to the metadata. Declaration public static IMetadata WithBehavior<TBehavior>(this IMetadata metadata) where TBehavior : IBehaviorDefinition, new() Parameters Type Name Description IMetadata metadata The metadata instance to extend. Returns Type Description IMetadata A new Zentient.Abstractions.Metadata.IMetadata instance with the added behavior. Type Parameters Name Description TBehavior The concrete behavior definition type, which must implement Zentient.Abstractions.Metadata.Definitions.IBehaviorDefinition. View Source WithCategory<TCategory>(IMetadata) Adds a category to the metadata. Declaration public static IMetadata WithCategory<TCategory>(this IMetadata metadata) where TCategory : ICategoryDefinition, new() Parameters Type Name Description IMetadata metadata The metadata instance to extend. Returns Type Description IMetadata A new Zentient.Abstractions.Metadata.IMetadata instance with the added category. Type Parameters Name Description TCategory The concrete category definition type, which must implement Zentient.Abstractions.Metadata.Definitions.ICategoryDefinition. View Source WithMergedTags(IMetadata, IMetadataReader) Merges tags from another Zentient.Abstractions.Metadata.Readers.IMetadataReader instance into the current metadata. Declaration public static IMetadata WithMergedTags(this IMetadata metadata, IMetadataReader other) Parameters Type Name Description IMetadata metadata The metadata instance to extend. IMetadataReader other The metadata reader to merge from. Returns Type Description IMetadata A new Zentient.Abstractions.Metadata.IMetadata instance with the merged tags. View Source WithTagIfNotExists<TTag, TValue>(IMetadata, TValue) Adds a tag to the metadata only if a tag with the same key does not already exist. Declaration public static IMetadata WithTagIfNotExists<TTag, TValue>(this IMetadata metadata, TValue value) where TTag : IMetadataTagDefinition, new() Parameters Type Name Description IMetadata metadata The metadata instance to extend. TValue value The value of the tag. Returns Type Description IMetadata A new Zentient.Abstractions.Metadata.IMetadata instance if the tag was added; otherwise, the original instance. Type Parameters Name Description TTag The concrete tag definition type, which must implement Zentient.Abstractions.Metadata.Definitions.IMetadataTagDefinition. TValue The type of the tag's value. View Source WithTag<TTag, TValue>(IMetadata, TValue) Adds or updates a tag on the metadata. Declaration public static IMetadata WithTag<TTag, TValue>(this IMetadata metadata, TValue value) where TTag : IMetadataTagDefinition, new() Parameters Type Name Description IMetadata metadata The metadata instance to extend. TValue value The value of the tag. Returns Type Description IMetadata A new Zentient.Abstractions.Metadata.IMetadata instance with the added or updated tag. Type Parameters Name Description TTag The concrete tag definition type, which must implement Zentient.Abstractions.Metadata.Definitions.IMetadataTagDefinition. TValue The type of the tag's value."
  },
  "api/Zentient.Metadata.MetadataReader.html": {
    "href": "api/Zentient.Metadata.MetadataReader.html",
    "title": "Class MetadataReader | Zentient.Metadata Documentation",
    "keywords": "Class MetadataReader A concrete, immutable implementation of Zentient.Abstractions.Metadata.Readers.IMetadataReader. This class encapsulates all read-only metadata operations. Inheritance object MetadataReader Implements IMetadataReader Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Zentient.Metadata Assembly: Zentient.Metadata.dll Syntax public sealed class MetadataReader : IMetadataReader Constructors View Source MetadataReader(IDictionary<string, object?>) Declaration public MetadataReader(IDictionary<string, object?> tags) Parameters Type Name Description IDictionary<string, object> tags Properties View Source Count Gets the number of metadata tags contained in this instance. Declaration public int Count { get; } Property Value Type Description int View Source Keys Gets an enumerable collection of all keys contained in this metadata instance. Declaration public IEnumerable<string> Keys { get; } Property Value Type Description IEnumerable<string> View Source Tags Gets an enumerable collection of all key-value pairs (tags) contained in this metadata instance. Declaration public IEnumerable<KeyValuePair<string, object?>> Tags { get; } Property Value Type Description IEnumerable<KeyValuePair<string, object>> View Source Values Gets an enumerable collection of all values contained in this metadata instance. Declaration public IEnumerable<object?> Values { get; } Property Value Type Description IEnumerable<object> Methods View Source ContainsKey(string) Determines whether this metadata instance contains a tag with the specified key. Declaration public bool ContainsKey(string key) Parameters Type Name Description string key The key to locate. Cannot be null or whitespace. Returns Type Description bool true if a tag with the key exists; otherwise, false. Exceptions Type Condition ArgumentNullException Thrown if key is null. ArgumentException Thrown if key is empty or whitespace. View Source GetValueOrDefault(string, object?) Gets the value associated with the specified key, or a default value if the key is not found. Declaration public object? GetValueOrDefault(string key, object? defaultValue = null) Parameters Type Name Description string key The key of the value to get. Cannot be null or whitespace. object defaultValue The value to return if the key is not found. Can be null. Returns Type Description object The value associated with the specified key, or defaultValue if the key is not found. Remarks If a tag exists with a null value, this method will return null. Exceptions Type Condition ArgumentNullException Thrown if key is null. ArgumentException Thrown if key is empty or whitespace. View Source GetValueOrDefault<TValue>(string, TValue) Gets the value associated with the specified key, cast to the specified type, or a default value if the key is not found or the value is not compatible. Declaration public TValue GetValueOrDefault<TValue>(string key, TValue defaultValue = default) Parameters Type Name Description string key The key of the value to get. Cannot be null or whitespace. TValue defaultValue The value to return if the key is not found or the value cannot be cast to TValue. Can be null. Returns Type Description TValue The value associated with the specified key, cast to TValue, or defaultValue if the key is not found or the value is not compatible. Type Parameters Name Description TValue The type to which the value should be cast. Remarks If a tag exists with a null value, this method will return null (for reference types or nullable value types), provided the value's type is compatible with TValue. Exceptions Type Condition ArgumentNullException Thrown if key is null. ArgumentException Thrown if key is empty or whitespace. View Source TryGetValue(string, out object?) Attempts to retrieve the value associated with the specified key. Declaration public bool TryGetValue(string key, out object? value) Parameters Type Name Description string key The key of the value to get. Cannot be null or whitespace. object value When this method returns, contains the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. Returns Type Description bool true if the value associated with the specified key was retrieved successfully; otherwise, false. Remarks If a tag exists with a null value, this method will return true, and value will be null. It is crucial to differentiate between a key not existing and a key existing with a null value. Exceptions Type Condition ArgumentNullException Thrown if key is null. ArgumentException Thrown if key is empty or whitespace. View Source TryGetValue<TValue>(string, out TValue) Attempts to retrieve the value associated with the specified key, casting it to the specified type. Declaration public bool TryGetValue<TValue>(string key, out TValue value) Parameters Type Name Description string key The key of the value to get. Cannot be null or whitespace. TValue value When this method returns, contains the value associated with the specified key, cast to TValue, if the key is found and the value is compatible; otherwise, the default value for TValue. Returns Type Description bool true if the value associated with the specified key was retrieved and is compatible with TValue; otherwise, false. Type Parameters Name Description TValue The type to which the value should be cast. Remarks If a tag exists with a null value, this method will return true, and value will be null (for reference types or nullable value types). This method returns false if the key does not exist or if the value cannot be cast to TValue. Exceptions Type Condition ArgumentNullException Thrown if key is null. ArgumentException Thrown if key is empty or whitespace. Implements Zentient.Abstractions.Metadata.Readers.IMetadataReader"
  },
  "api/Zentient.Metadata.MetadataRegistry.html": {
    "href": "api/Zentient.Metadata.MetadataRegistry.html",
    "title": "Class MetadataRegistry | Zentient.Metadata Documentation",
    "keywords": "Class MetadataRegistry Central registry for presets and standard metadata. Supports registration and lookup by type, tag, or preset key. Inheritance object MetadataRegistry Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Namespace: Zentient.Metadata Assembly: Zentient.Metadata.dll Syntax public static class MetadataRegistry Properties View Source RegisteredKeys Declaration public static IEnumerable<object> RegisteredKeys { get; } Property Value Type Description IEnumerable<object> Methods View Source RegisterPreset(object, IMetadata) Declaration public static void RegisterPreset(object key, IMetadata metadata) Parameters Type Name Description object key IMetadata metadata View Source TryGetPreset(object, out IMetadata?) Declaration public static bool TryGetPreset(object key, out IMetadata? metadata) Parameters Type Name Description object key IMetadata metadata Returns Type Description bool"
  },
  "api/Zentient.Metadata.html": {
    "href": "api/Zentient.Metadata.html",
    "title": "Namespace Zentient.Metadata | Zentient.Metadata Documentation",
    "keywords": "Namespace Zentient.Metadata Classes Metadata Serves as the public-facing factory for creating new Zentient.Abstractions.Metadata.IMetadata instances. This is the primary entry point for consumers to interact with the metadata system. MetadataExtensions Provides a rich set of fluent, type-safe extension methods for working with Zentient.Abstractions.Metadata.IMetadata. These methods enhance developer ergonomics and enable intuitive interactions with the metadata system. MetadataReader A concrete, immutable implementation of Zentient.Abstractions.Metadata.Readers.IMetadataReader. This class encapsulates all read-only metadata operations. MetadataRegistry Central registry for presets and standard metadata. Supports registration and lookup by type, tag, or preset key."
  },
  "docs/Zentient_Metadata_Metadata-Attribute-Specification.html": {
    "href": "docs/Zentient_Metadata_Metadata-Attribute-Specification.html",
    "title": "Zentient.Metadata Attribute Specification | Zentient.Metadata Documentation",
    "keywords": "Zentient.Metadata Attribute Specification Purpose This document specifies the design, semantics, and discoverability rules for attributes in the Zentient.Metadata ecosystem, focusing on their role in generating and discovering IMetadata and IMetadataDefinition instances. It also covers integration and usage of Zentient.Abstractions.Common.Metadata attributes for legacy and cross-package compatibility. 1. Attribute Categories Core Attribute Types Attribute Name Namespace Purpose Targets Repeatable Notes BehaviorDefinitionAttribute Zentient.Metadata.Attributes Declares a type as a metadata behavior definition. Interface, Class No Must implement IBehaviorDefinition CategoryDefinitionAttribute Zentient.Metadata.Attributes Declares a type as a metadata category definition. Interface, Class No Must implement ICategoryDefinition MetadataTagAttribute Zentient.Metadata.Attributes Associates a metadata tag on a type or member. Class, Property, Method Yes Requires a tag type and a value DefinitionCategoryAttribute Zentient.Abstractions.Common.Metadata Declares a category for a definition. Interface, Class No Used for legacy and cross-package integration DefinitionTagAttribute Zentient.Abstractions.Common.Metadata Declares tags for a definition. Interface, Class Yes Used for legacy and cross-package integration Custom Attributes Zentient.Metadata.Attributes.* User-defined attributes for extensions, diagnostics, etc. Any Varies Must inherit from MetadataAttribute 2. Attribute Semantics Declarative Only: Attributes do NOT directly execute logic; they declare metadata intent. Conversion: Attribute scanners convert discovered attributes to equivalent IMetadata instances using a well-defined mapping. Immutability: Attribute metadata is immutable at runtime. Inheritance: Attribute discovery respects inheritance where [Inherited = true] is specified. Some attributes are only applied to the declaring type. Cross-Package Compatibility: DefinitionCategoryAttribute and DefinitionTagAttribute from Zentient.Abstractions.Common.Metadata are supported for legacy, interoperability, and registry purposes. 3. Discovery Rules General Discovery Workflow: Enumerate Types: Assembly scan for all types with attribute(s) deriving from MetadataAttribute, as well as those using DefinitionCategoryAttribute and DefinitionTagAttribute. Attribute Extraction: For each type/member, retrieve all relevant metadata attributes (including via inheritance as applicable). Mapping: Map attributes to corresponding metadata keys and values using the following rules: BehaviorDefinitionAttribute: The attribute itself serves as a marker. The scanner creates a behavior instance from the attributed type. CategoryDefinitionAttribute: The attribute itself serves as a marker. The scanner creates a category instance from the attributed type. MetadataTagAttribute: The key is the full name of the tag type (tagType.FullName), and the value is the provided value. DefinitionCategoryAttribute: The key is \"category\", the value is the CategoryName property. Used for registry and catalog integration. DefinitionTagAttribute: The key is \"tags\", the value is the array of tag strings (Tags property). Used for registry and catalog integration. Conflict Resolution: If multiple attributes declare the same key, resolution order is: Most-derived type wins. Explicit Order/Priority property wins if present. Otherwise, last declared wins. Composition: Construct an IMetadataBuilder, apply all discovered tags/behaviors/categories, then build the final immutable IMetadata. Special Notes: Composite Attributes: (e.g., [Behaviors(...)]) must be decomposed by the scanner and treated as multiple behaviors. Repeatable Attributes: Multiple tags with the same key and different values raise a warning (see analyzer ZMD002). Legacy/Abstractions Attributes: DefinitionCategoryAttribute and DefinitionTagAttribute are treated equivalently to Zentient.Metadata attributes, but are primarily used for registration/catalog scenarios. Interoperability: Scanners should unify both Zentient.Metadata and Zentient.Abstractions.Common.Metadata attributes into a single metadata representation, ensuring smooth integration across packages. 4. Attribute Discovery APIs Core Scanner public interface IAttributeMetadataScanner { IMetadata Scan(Type type); IMetadata Scan(MemberInfo member); IEnumerable<(MemberInfo member, IMetadata metadata)> ScanAll(Assembly assembly); } Conversion Helper public static class AttributeMetadataConverter { public static IMetadata Convert(IEnumerable<Attribute> attributes); } Note: The converter must accept both MetadataAttribute and DefinitionCategoryAttribute/DefinitionTagAttribute. 5. Extensibility Custom Attributes: Users may define new attributes inheriting from MetadataAttribute. These must be registered with the scanner/converter to participate in metadata generation. Legacy Extension: Additional attributes from Zentient.Abstractions.Common.Metadata may be incorporated for legacy/migration scenarios. Presets Registry: Attribute-based presets may be registered and discovered via [Preset(\"name\")] attributes. 6. DX Considerations IDE Discoverability: All attributes should have clear XML documentation and usage examples. Roslyn Analyzer Rules: Warn on incorrect usage, duplicates, or missing required attributes. Unit Tests: Coverage for attribute-to-metadata conversion, inheritance, and conflict resolution. Unified Metadata Surface: Developers should be able to query all metadata, regardless of whether it was declared via Zentient.Metadata or Zentient.Abstractions attributes. 7. Acceptance Criteria All public attribute types (including legacy/abstractions) are discoverable via assembly/type/member scan. Attribute scanners yield deterministic, immutable IMetadata instances. Duplicate/conflicting attribute applications trigger analyzer warnings. Custom attributes are supported via registration/extension. Registry/catalog flows can utilize both Zentient.Metadata and Zentient.Abstractions.Common.Metadata attributes. 8. Examples Behavior & Category [BehaviorDefinition] public class AuditableBehavior : IBehaviorDefinition { } [CategoryDefinition] public class ServiceCategory : ICategoryDefinition { } [DefinitionCategory(\"service\")] public interface IServiceDefinition { } Tags [MetadataTag(typeof(VersionTag), \"1.2\")] [MetadataTag(typeof(CacheableTag), true)] public class MyService { } [DefinitionTag(\"auditable\", \"cacheable\")] public interface IServiceDefinition { } Discovery (Unified) var metadata = AttributeMetadataReader.GetMetadata(typeof(MyService)); // metadata will have tags \"VersionTag\"=\"1.2\", \"CacheableTag\"=true var legacyMetadata = AttributeMetadataReader.GetMetadata(typeof(IServiceDefinition)); // metadata will have \"category\"=\"service\", \"tags\"=[\"auditable\", \"cacheable\"] 9. Integration with Zentient.Abstractions Attributes discovered in Metadata should be compatible with those declared in Abstractions (e.g., DefinitionTagAttribute, DefinitionCategoryAttribute). The scanner should unify both sources for IMetadataDefinition generation. Catalog and registry APIs should support querying by both Zentient.Metadata and Zentient.Abstractions.Common.Metadata attributes. 10. Future-Proofing Attribute properties may include Order, Priority, and PresetName for advanced scenarios. Consider supporting source generators for compile-time metadata emission. Maintain backward compatibility with legacy abstractions attributes for migration purposes. End of Specification"
  },
  "docs/architecture.html": {
    "href": "docs/architecture.html",
    "title": "Architecture Overview | Zentient.Metadata Documentation",
    "keywords": "Architecture Overview This document describes the architecture and design principles of the Zentient Library Template. Design Principles 1. Separation of Concerns Each Directory.. file handles a specific aspect of the build process: Directory.Build.* - Core build configuration Directory.Pack.* - NuGet packaging Directory.Sign.* - Code signing and strong naming Directory.Test.* - Testing infrastructure Directory.Quality.* - Code quality and analysis Directory.Security.* - Security scanning and validation Directory.Documentation.* - Documentation generation Directory.Performance.* - Performance monitoring 2. Convention over Configuration The template follows established .NET conventions: Standard project structure (src/, tests/, docs/) MSBuild property and target naming NuGet package metadata standards .NET analyzer integration patterns 3. Progressive Enhancement Features can be enabled/disabled through template parameters: Essential features enabled by default Advanced features (performance, security) opt-in Graceful degradation when tools aren't available 4. Enterprise-Ready Built for production use with: Comprehensive automation Quality gates and validation Security compliance Audit trails and reporting Build System Architecture Core Build Flow graph TD A[dotnet build] --> B[Directory.Build.props] B --> C[Load Feature Configurations] C --> D{Feature Enabled?} D -->|Yes| E[Execute Feature Props/Targets] D -->|No| F[Skip Feature] E --> G[Continue Build] F --> G G --> H[Compile Code] H --> I[Run Analyzers] I --> J[Execute Tests] J --> K[Generate Artifacts] Feature Integration Each feature follows a consistent pattern: Props File - Configuration and properties Targets File - Build tasks and automation Conditional Import - Only loaded when enabled Graceful Fallback - Works even if tools aren't installed Code Organization Library Structure src/ ├── YourLibrary.csproj # Main project ├── GlobalUsings.cs # Shared using statements ├── ExampleService.cs # Example implementation ├── Interfaces/ # Interface definitions ├── Models/ # Data models ├── Services/ # Business logic └── Extensions/ # Extension methods Test Structure tests/ ├── YourLibrary.Tests.csproj # Test project ├── GlobalUsings.cs # Test using statements ├── ExampleServiceTests.cs # Unit tests ├── Integration/ # Integration tests ├── Performance/ # Performance tests └── TestData/ # Test data files Zentient Integration Core Abstractions The template integrates with Zentient.Abstractions: // Entity identification public class MyService : IIdentifiable { public string Id { get; } = Guid.NewGuid().ToString(); } // Result handling public IResult<string> ProcessData(string input) { if (string.IsNullOrEmpty(input)) return Results.Error<string>(\"Input cannot be empty\"); return Results.Success(input.ToUpper()); } // Configuration public class MyOptions : IHasName, IHasDescription { public string Name { get; init; } = \"MyService\"; public string Description { get; init; } = \"Example service\"; } Extension Points The template provides extension points for: Custom analyzers Additional build targets Custom documentation generation Performance benchmarks Security validators Quality Assurance Code Quality Pipeline graph LR A[Code] --> B[EditorConfig] B --> C[Analyzers] C --> D[StyleCop] D --> E[Security Scan] E --> F[API Validation] F --> G[Documentation Check] G --> H[Quality Gate] Testing Strategy Unit Tests - Individual component testing Integration Tests - Component interaction testing Performance Tests - Benchmark validation Security Tests - Vulnerability assessment API Tests - Public interface validation Security Architecture Security Layers Dependency Scanning - NuGet package vulnerability detection Code Analysis - Static security analysis Cryptographic Validation - Algorithm and key strength validation Input Validation - Data sanitization and validation Assembly Signing - Code integrity verification Compliance The template supports compliance with: OWASP security standards Microsoft security guidelines Enterprise security policies Industry best practices Performance Monitoring Monitoring Strategy graph TD A[Performance Tests] --> B[Benchmark Execution] B --> C[Memory Analysis] C --> D[Baseline Comparison] D --> E{Regression?} E -->|Yes| F[Fail Build] E -->|No| G[Update Baseline] F --> H[Generate Report] G --> H Metrics Tracked Execution time Memory allocation GC behavior Throughput Resource utilization Documentation System Documentation Types API Documentation - XML comments → DocFX Conceptual Documentation - Markdown files Code Samples - Executable examples Architecture Documentation - Design decisions User Guides - Getting started and tutorials Generation Pipeline graph LR A[XML Comments] --> B[DocFX] C[Markdown Files] --> B D[Code Samples] --> B B --> E[HTML Documentation] E --> F[Validation] F --> G[Publication] Extensibility Adding Custom Features Create Directory.CustomFeature.props for configuration Create Directory.CustomFeature.targets for automation Add conditional import to Directory.Build.props Add template parameter for feature toggle Update documentation Custom Analyzers <ItemGroup Condition=\"'$(EnableCustomAnalysis)' == 'true'\"> <PackageReference Include=\"YourCustomAnalyzer\" Version=\"1.0.0\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets> </PackageReference> </ItemGroup> Deployment Strategy Package Distribution Development - Local package feed CI/CD - Automated package creation Staging - Pre-release packages Production - Official NuGet.org publication Versioning Strategy Semantic versioning (SemVer) Automatic version increment Pre-release suffixes for development Git commit integration Maintenance Template Updates Update core Zentient.Abstractions reference Update analyzer package versions Refresh Directory.. configurations Test with latest .NET versions Update documentation Best Practices Regular dependency updates Security vulnerability monitoring Performance regression testing Documentation maintenance Community feedback integration This architecture ensures the template remains maintainable, extensible, and production-ready while providing a rich development experience for Zentient ecosystem libraries."
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started with Zentient.LibraryTemplate | Zentient.Metadata Documentation",
    "keywords": "Getting Started with Zentient.LibraryTemplate This guide will help you get up and running with your new Zentient library project. Prerequisites .NET 8.0 SDK or later Visual Studio Code (recommended) or Visual Studio Git (for version control) Quick Start 1. Clone and Setup # If you created this from the template, you're already ready! # Otherwise, clone your repository: git clone <your-repo-url> cd <your-project-name> # Restore dependencies dotnet restore 2. Build and Test # Build the solution dotnet build # Run tests dotnet test # Run tests with coverage dotnet test --collect:\"XPlat Code Coverage\" 3. Development Workflow The project includes comprehensive automation through Directory.. files: # Full build with all checks dotnet build -c Release # Run code analysis dotnet build -p:RunCodeAnalysis=true # Run security scan dotnet build -p:RunSecurityCodeAnalysis=true # Generate documentation dotnet build -p:GenerateDocumentation=true # Create NuGet package dotnet pack -c Release Project Structure YourLibrary/ ├── src/ # Main library source code │ ├── YourLibrary.csproj # Main project file │ ├── ExampleService.cs # Example implementation (replace) │ └── GlobalUsings.cs # Global using statements ├── tests/ # Unit tests │ ├── YourLibrary.Tests.csproj # Test project file │ ├── ExampleServiceTests.cs # Example tests (replace) │ └── GlobalUsings.cs # Test global usings ├── docs/ # Documentation │ └── getting-started.md # This file ├── src/ # Library source code ├── tests/ # Unit tests ├── docs/ # Documentation ├── .vscode/ # VS Code configuration ├── .github/ # GitHub workflows and templates ├── .vscode/ # VS Code configuration ├── analyzers/ # Code analysis rules ├── Directory.*.props # Build configuration ├── Directory.*.targets # Build automation └── YourLibrary.sln # Solution file Key Features 🏗️ Build Automation Multi-target framework support Automatic versioning NuGet package generation Source linking for debugging 🧪 Testing Infrastructure xUnit test framework Code coverage reporting Benchmark testing support Continuous testing with file watching 📊 Code Quality Microsoft analyzers StyleCop code style enforcement Security analysis API surface validation 🔐 Security Vulnerability scanning Dependency validation Cryptographic standards enforcement Security compliance checking 📚 Documentation XML documentation generation DocFX integration API documentation Code sample validation ⚡ Performance BenchmarkDotNet integration Memory analysis Performance regression detection Load testing capabilities Development Workflow VS Code (Recommended) Open in VS Code: The project includes complete VS Code configuration Install Extensions: VS Code will prompt to install recommended extensions Build: Use Ctrl+Shift+P → \"Tasks: Run Task\" → \"build\" Test: Use Ctrl+Shift+P → \"Tasks: Run Task\" → \"test\" Debug: Use F5 to debug tests Command Line # Watch for changes and rebuild dotnet watch build # Watch for changes and run tests dotnet watch test # Format code dotnet format # Clean build artifacts dotnet clean Customization Replacing Example Code Update Project Names: Replace Zentient.LibraryTemplate with your actual library name Replace ExampleService: Implement your actual library functionality Update Tests: Replace example tests with your actual test cases Update Documentation: Modify README.md and docs/ with your library-specific information Configuration Most settings can be customized through MSBuild properties: <!-- In your .csproj or Directory.Build.props --> <PropertyGroup> <EnableSigning>true</EnableSigning> <EnableTesting>true</EnableTesting> <EnableQuality>true</EnableQuality> <EnableSecurity>true</EnableSecurity> <EnableDocumentation>true</EnableDocumentation> <EnablePerformance>false</EnablePerformance> </PropertyGroup> CI/CD Integration The project is ready for CI/CD with: GitHub Actions workflows (if using GitHub) Azure DevOps pipelines (if using Azure DevOps) Docker containerization support Automated testing and quality checks Best Practices Code Organization Follow the existing namespace structure Implement interfaces from Zentient.Abstractions Use the IResult pattern for error handling Add comprehensive XML documentation Testing Maintain high test coverage (aim for >90%) Include both unit and integration tests Use descriptive test method names Follow the Arrange-Act-Assert pattern Documentation Document all public APIs Include code examples in XML comments Update CHANGELOG.md for each release Keep README.md current Performance Use BenchmarkDotNet for performance testing Monitor memory allocations Validate performance against baselines Profile regularly during development Troubleshooting Common Issues Build Errors: Ensure .NET 8.0 SDK is installed Run dotnet restore to restore packages Check for syntax errors in .csproj files Test Failures: Verify test project references are correct Check test method signatures Ensure test data is valid Package Issues: Verify package metadata in Directory.Pack.props Check for missing dependencies Validate version numbers Getting Help Check the Zentient.Abstractions documentation Review the example implementations File issues in the project repository Next Steps Implement Your Library: Replace the example code with your actual implementation Add Tests: Write comprehensive tests for your functionality Update Documentation: Customize the documentation for your specific library Configure CI/CD: Set up continuous integration for your project Publish: Create and publish your NuGet package Happy coding! 🚀"
  }
}