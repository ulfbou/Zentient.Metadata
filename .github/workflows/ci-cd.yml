# CI/CD for Zentient Monorepo - production-grade
# Builds, tests, packs, and publishes .NET libraries and analyzers.
# - Multi-target builds for class libraries: net8.0, net9.0
# - Analyzers target: netstandard2.0
# - Tests run per-matrix framework
# - Pack & publish on semantic tag pushes
# Rationale comments accompany each job/step for maintainability and auditing.

name: CI/CD

on:
  push:
    branches: [ develop ]
    tags: [ 'v*.*.*' ] # Release publishing only for semantic tags like v1.2.3
  pull_request:
    branches: [ main ]

# Keep common envs minimal and secure; avoid leaking secrets to logs
env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_NOLOGO: true
  NUGET_PACKAGES: ${{ runner.tool_cache }}/nuget/packages

concurrency:
  # Ensure a single CI run per branch/ref to avoid duplicated work
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # 1) Restore job: centralize restore & populate cache for speed
  restore:
    name: Restore NuGet Packages
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        # Keep LFS and submodules disabled by default for speed; enable if required

      - name: Setup .NET 9.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ${{ env.NUGET_PACKAGES }}
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/Directory.Pack.props', '**/Directory.Build.props') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: dotnet restore (solution)
        run: |
          set -euo pipefail
          dotnet restore
        # Fail-fast: immediate exit on error to expose restore diagnostics

  # New job: validate IsPackable policy before builds
  validate-packability:
    name: Validate IsPackable Policy
    needs: restore
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Enforce packability rules
        # This step fails the job if any rule is violated.
        run: |
          set -euo pipefail
          echo "Validating IsPackable rules for src/ and tests/ projects"

          missing_packable=()
          wrong_test_packable=()
          analyzer_not_packable=()

          # Validate src projects: must explicitly contain <IsPackable>true</IsPackable>
          for proj in $(git ls-files 'src/**/*.csproj' 'src/*.csproj'); do
            if ! grep -q '<IsPackable>true</IsPackable>' "$proj"; then
              missing_packable+=("$proj")
            fi
          done

          # Validate analyzer projects are packable (Zentient.Metadata.Analyzers etc.)
          for aproj in $(git ls-files 'src/*.Analyzers.csproj' 'src/**/*.Analyzers.csproj'); do
            if ! grep -q '<IsPackable>true</IsPackable>' "$aproj"; then
              analyzer_not_packable+=("$aproj")
            fi
          done

          # Validate test projects explicitly set IsPackable to false
          for tproj in $(git ls-files 'tests/*.csproj' 'tests/**/*.csproj'); do
            if ! grep -q '<IsPackable>false</IsPackable>' "$tproj"; then
              wrong_test_packable+=("$tproj")
            fi
          done

          failed=0
          if [ ${#missing_packable[@]} -gt 0 ]; then
            echo "ERROR: The following src/ projects do not contain an explicit '<IsPackable>true</IsPackable>' entry:" >&2
            for f in "${missing_packable[@]}"; do echo "  - $f" >&2; done
            echo >&2
            echo "Recommendation: add the following to each library .csproj under src/:" >&2
            echo "  <PropertyGroup>" >&2
            echo "    <IsPackable>true</IsPackable>" >&2
            echo "  </PropertyGroup>" >&2
            failed=1
          fi

          if [ ${#analyzer_not_packable[@]} -gt 0 ]; then
            echo "ERROR: The following analyzer projects must be packable (IsPackable=true):" >&2
            for f in "${analyzer_not_packable[@]}"; do echo "  - $f" >&2; done
            failed=1
          fi

          if [ ${#wrong_test_packable[@]} -gt 0 ]; then
            echo "ERROR: The following test projects do not explicitly set '<IsPackable>false</IsPackable>':" >&2
            for f in "${wrong_test_packable[@]}"; do echo "  - $f" >&2; done
            echo >&2
            echo "Recommendation: add the following to each test .csproj under tests/:" >&2
            echo "  <PropertyGroup>" >&2
            echo "    <IsPackable>false</IsPackable>" >&2
            echo "  </PropertyGroup>" >&2
            failed=1
          fi

          if [ "$failed" -ne 0 ]; then
            echo "Packability validation failed." >&2
            exit 2
          fi

          echo "Packability validation passed."

  # 2) Build class libraries matrix (net8.0, net9.0)
  build:
    name: Build Projects (class libraries)
    needs: [ restore, validate-packability ]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        framework: [ net8.0, net9.0 ]
    timeout-minutes: 30
    concurrency:
      group: build-${{ matrix.framework }}-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET ${{ matrix.framework }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ matrix.framework }}

      - name: Build packable class libraries for ${{ matrix.framework }}
        run: |
          set -euo pipefail
          echo "Building packable class libraries for ${{ matrix.framework }}"
          found=0
          for proj in $(git ls-files 'src/**/*.csproj' 'src/*.csproj'); do
            # Only build projects intended to be packed (IsPackable true)
            if grep -q '<IsPackable>true</IsPackable>' "$proj"; then
              found=1
              echo "Building $proj for ${{ matrix.framework }}"
              dotnet build "$proj" -c Release -f ${{ matrix.framework }} --no-restore || { echo "Build failed: $proj"; exit 1; }
            fi
          done
          if [ "$found" -eq 0 ]; then
            echo "No packable class libraries found for build matrix ${{ matrix.framework }}"
          fi

  # 3) Build analyzers separately using netstandard2.0
  build-analyzers:
    name: Build Analyzer Projects (netstandard2.0)
    needs: restore
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 8.0 (for analyzer build tooling)
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Build analyzers
        run: |
          set -euo pipefail
          echo "Building analyzer projects (targeting netstandard2.0)"
          found=0
          for proj in $(git ls-files 'src/*.Analyzers.csproj' 'src/**/*.Analyzers.csproj'); do
            found=1
            echo "Building analyzer: $proj"
            dotnet build "$proj" -c Release --no-restore || { echo "Analyzer build failed: $proj"; exit 1; }
          done
          if [ "$found" -eq 0 ]; then
            echo "No analyzer projects found. Skipping analyzer build."
          fi

  # 4) Test job: run tests across matrix frameworks
  test:
    name: Test Projects
    needs: [ build, build-analyzers ]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        framework: [ net8.0, net9.0 ]
    timeout-minutes: 30
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET ${{ matrix.framework }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ matrix.framework }}

      - name: Run tests (tests/)
        run: |
          set -euo pipefail
          echo "Running tests for ${{ matrix.framework }}"
          mkdir -p tests/TestResults
          found=0
          for proj in $(git ls-files 'tests/*.csproj' 'tests/**/*.csproj'); do
            found=1
            echo "Testing $proj for ${{ matrix.framework }}"
            dotnet test "$proj" -c Release -f ${{ matrix.framework }} --no-build --logger "trx;LogFileName=$(basename $proj).trx" --results-directory tests/TestResults || { echo "Tests failed for $proj"; exit 1; }
          done
          if [ "$found" -eq 0 ]; then
            echo "No test projects found."
          fi

      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.framework }}
          path: tests/TestResults/

  # 5) Pack job: create NuGet packages for packable projects
  pack:
    name: Pack NuGet Packages
    needs: test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 9.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      - name: Determine package version
        id: pkgver
        run: |
          set -euo pipefail
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # Strip v prefix if present: refs/tags/v1.2.3 -> 1.2.3
            tag=${GITHUB_REF#refs/tags/}
            ver=${tag#v}
            echo "Detected release tag: $tag -> using version $ver"
            echo "version=$ver" >> $GITHUB_OUTPUT
          else
            # Try to derive a base semantic version from any VersionPrefix in the repo
            base=$(git grep -m1 "<VersionPrefix>" || true)
            if [ -n "$base" ]; then
              # extract using sed: <VersionPrefix>1.2.3</VersionPrefix>
              base=$(git grep -m1 "<VersionPrefix>" | sed -E 's/.*<VersionPrefix>([^<]+)<\/VersionPrefix>.*/\1/')
            else
              base="0.0.0"
            fi
            shortsha=$(git rev-parse --short=8 HEAD)
            date=$(date -u +%Y%m%d%H%M)
            ver="${base}-ci.${date}.${shortsha}"
            echo "Using CI package version: $ver"
            echo "version=$ver" >> $GITHUB_OUTPUT
          fi

      - name: Create artifacts dir
        run: mkdir -p artifacts

      - name: Pack projects (include symbols and source)
        run: |
          set -euo pipefail
          echo "Packing projects with PackageVersion=${{ steps.pkgver.outputs.version }}"
          found=0
          for proj in $(git ls-files 'src/*.csproj' 'src/**/*.csproj'); do
            if grep -q '<IsPackable>true</IsPackable>' "$proj" || grep -q '<PackageId>' "$proj"; then
              found=1
              echo "Packing $proj"
              # --include-symbols produces .snupkg for symbol packages on modern SDKs
              dotnet pack "$proj" -c Release --no-build -p:PackageVersion=${{ steps.pkgver.outputs.version }} --include-symbols --include-source -o artifacts || { echo "Pack failed: $proj"; exit 1; }
            fi
          done
          if [ "$found" -eq 0 ]; then
            echo "No packable projects found."
          fi

      - name: Upload NuGet packages as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nuget-packages
          path: artifacts/*

  # Optional: sign symbol packages if signing key available
  sign-symbols:
    name: Sign symbol packages (optional)
    needs: pack
    runs-on: ubuntu-latest
    if: ${{ secrets.SIGNING_KEY != '' }}
    timeout-minutes: 20
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download package artifacts
        uses: actions/download-artifact@v4
        with:
          name: nuget-packages
          path: ./artifacts

      - name: Sign symbols (placeholder step)
        env:
          SIGNING_KEY: ${{ secrets.SIGNING_KEY }}
        run: |
          set -euo pipefail
          echo "Signing pipeline invoked."
          echo "This job is a placeholder. Implement signing using your preferred tool/service."
          # Example: call out to a signing service or run a local sign tool here.
          # For safety, we do not attempt to sign without a concrete signing tool configured.

  # 6) Publish job: pushes packages to NuGet.org and creates a GitHub Release
  publish:
    name: Publish to NuGet & Create Release
    needs: [ pack, sign-symbols ]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    timeout-minutes: 30
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download package artifacts
        uses: actions/download-artifact@v4
        with:
          name: nuget-packages
          path: ./artifacts

      - name: Setup .NET 9.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      - name: Push packages to NuGet.org (packages and symbols)
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        run: |
          set -euo pipefail
          pushed=0
          for pkg in artifacts/*.nupkg; do
            if [ -f "$pkg" ]; then
              echo "Pushing $pkg to NuGet.org"
              dotnet nuget push "$pkg" --api-key "$NUGET_API_KEY" --source https://api.nuget.org/v3/index.json --skip-duplicate || { echo "Failed to push $pkg"; exit 1; }
              pushed=$((pushed+1))
            fi
          done
          # push symbol packages (.snupkg)
          for sym in artifacts/*.snupkg; do
            if [ -f "$sym" ]; then
              echo "Pushing symbol package $sym to NuGet.org"
              dotnet nuget push "$sym" --api-key "$NUGET_API_KEY" --source https://api.nuget.org/v3/index.json --skip-duplicate || { echo "Failed to push symbol package $sym"; exit 1; }
            fi
          done
          if [ "$pushed" -eq 0 ]; then
            echo "No packages found to push."
            exit 1
          fi

      - name: Optionally push to internal feed if configured
        env:
          INTERNAL_FEED_URL: ${{ secrets.INTERNAL_FEED_URL }}
          INTERNAL_FEED_API_KEY: ${{ secrets.INTERNAL_FEED_API_KEY }}
        run: |
          set -euo pipefail
          if [ -n "${INTERNAL_FEED_URL:-}" ] && [ -n "${INTERNAL_FEED_API_KEY:-}" ]; then
            echo "Pushing packages to internal feed $INTERNAL_FEED_URL"
            for pkg in artifacts/*.nupkg; do
              if [ -f "$pkg" ]; then
                dotnet nuget push "$pkg" --api-key "$INTERNAL_FEED_API_KEY" --source "$INTERNAL_FEED_URL" --skip-duplicate || { echo "Failed to push $pkg to internal feed"; exit 1; }
              fi
            done
          else
            echo "No internal feed configured. Skipping internal publish."
          fi

      - name: Create GitHub Release and attach artifacts
        uses: softprops/action-gh-release@v2
        with:
          files: |
            artifacts/*.nupkg
            artifacts/*.snupkg
            CHANGELOG.md
            LICENSE
            src/**/README.md
          body_path: CHANGELOG.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

# End of workflow
# Notes (operational):
# - This workflow intentionally separates analyzer builds from class-library matrix to respect netstandard targets.
# - Caching keys include csproj and Directory.*.props to avoid stale caches when package-lists change.
# - PackageVersion is derived from tag when releasing; otherwise CI prerelease is used and attempts to use VersionPrefix when available.
# - Symbol packages (.snupkg) are pushed to NuGet.org along with .nupkg.
# - Optional sign-symbols job and internal feed publish are gated by secrets (SIGNING_KEY, INTERNAL_FEED_*).
# - Internal process documents (Mistakes.md, Goals.md, Decisions.md) are intentionally NOT created in this repository; they must be kept private and external to the repo as requested.
